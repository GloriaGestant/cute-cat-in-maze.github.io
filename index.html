<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ú–∏–ª—ã–π –ö–æ—Ç–∏–∫ –≤ –õ–∞–±–∏—Ä–∏–Ω—Ç–µ - –£—Ä–æ–≤–Ω–∏</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
            color: white;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            overflow-x: hidden;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 1200px;
            width: 100%;
            gap: 20px;
            position: relative;
            z-index: 1;
        }
        
        header {
            text-align: center;
            margin-bottom: 10px;
        }
        
        h1 {
            font-size: 2.8rem;
            margin-bottom: 8px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            color: #fff;
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            margin-bottom: 10px;
        }
        
        /* –≠–∫—Ä–∞–Ω –≤—ã–±–æ—Ä–∞ —É—Ä–æ–≤–Ω–µ–π */
        .level-select-screen {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .level-select-title {
            font-size: 2.2rem;
            margin-bottom: 20px;
            color: #FFD700;
            text-align: center;
        }
        
        .levels-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            width: 100%;
            max-width: 800px;
            margin-bottom: 30px;
        }
        
        @media (max-width: 768px) {
            .levels-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        @media (max-width: 480px) {
            .levels-grid {
                grid-template-columns: 1fr;
            }
        }
        
        .level-card {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            border: 3px solid transparent;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        .level-card.unlocked {
            border-color: #9370DB;
        }
        
        .level-card.unlocked:hover {
            transform: translateY(-5px);
            border-color: #FFD700;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        }
        
        .level-card.locked {
            opacity: 0.6;
            cursor: not-allowed;
            background: rgba(0, 0, 0, 0.5);
        }
        
        .level-card.new {
            animation: pulse 2s infinite;
            border-color: #FFD700;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 215, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0); }
        }
        
        .level-number {
            font-size: 2.5rem;
            font-weight: bold;
            color: #9370DB;
            margin-bottom: 10px;
        }
        
        .level-card.unlocked .level-number {
            color: #FFD700;
        }
        
        .level-name {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .level-description {
            font-size: 0.9rem;
            opacity: 0.8;
            margin-bottom: 15px;
            min-height: 40px;
        }
        
        .level-stats {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            margin-top: 10px;
        }
        
        .best-score {
            font-size: 0.9rem;
            color: #90EE90;
            margin-bottom: 5px;
        }
        
        .stars {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }
        
        .star {
            font-size: 1.2rem;
            color: #ccc;
        }
        
        .star.filled {
            color: #FFD700;
        }
        
        .lock-icon {
            font-size: 2rem;
            margin-bottom: 10px;
            color: #aaa;
        }
        
        .current-level-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 1.5rem;
        }
        
        /* –ò–≥—Ä–æ–≤–æ–π —ç–∫—Ä–∞–Ω */
        .game-screen {
            width: 100%;
            display: none;
            flex-direction: column;
            align-items: center;
            position: relative;
            z-index: 2;
        }
        
        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            margin-bottom: 15px;
            padding: 0 10px;
        }
        
        .current-level-info {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1.2rem;
            background: rgba(0, 0, 0, 0.3);
            padding: 8px 15px;
            border-radius: 10px;
        }
        
        .back-to-levels {
            padding: 10px 20px;
            background-color: rgba(147, 112, 219, 0.8);
            border: none;
            border-radius: 50px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .back-to-levels:hover {
            background-color: #8A2BE2;
            transform: translateY(-2px);
        }
        
        .game-wrapper {
            position: relative;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #gameCanvas {
            background-color: #2a2a3a;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            max-width: 100%;
            display: block;
        }
        
        .stats {
            display: flex;
            justify-content: space-between;
            width: 100%;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px 25px;
            margin-bottom: 15px;
            font-size: 1.4rem;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }
        
        .steps {
            color: #FFD700;
        }
        
        .timer {
            color: #90EE90;
        }
        
        .controls {
            margin-top: 20px;
            text-align: center;
        }
        
        .keyboard-controls {
            margin-bottom: 20px;
        }
        
        .keyboard-controls h3 {
            margin-bottom: 10px;
            font-size: 1.2rem;
        }
        
        .keys {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .key {
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 8px 15px;
            font-weight: bold;
            min-width: 50px;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        .mobile-controls {
            display: none;
            margin-top: 25px;
            width: 100%;
        }
        
        .mobile-controls h3 {
            margin-bottom: 15px;
            font-size: 1.2rem;
        }
        
        .control-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 15px;
            max-width: 300px;
            margin: 0 auto;
        }
        
        .control-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background-color: rgba(147, 112, 219, 0.8);
            border: none;
            color: white;
            font-size: 1.8rem;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .control-btn:active {
            transform: scale(0.95);
            background-color: rgba(138, 43, 226, 0.8);
        }
        
        .btn-up {
            grid-column: 2;
            grid-row: 1;
        }
        
        .btn-left {
            grid-column: 1;
            grid-row: 2;
        }
        
        .btn-right {
            grid-column: 3;
            grid-row: 2;
        }
        
        .btn-down {
            grid-column: 2;
            grid-row: 3;
        }
        
        .btn-center {
            grid-column: 2;
            grid-row: 2;
            opacity: 0;
            pointer-events: none;
        }
        
        .actions {
            margin-top: 20px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 50px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        .btn-primary {
            background-color: #9370DB;
            color: white;
        }
        
        .btn-primary:hover {
            background-color: #8A2BE2;
            transform: translateY(-3px);
        }
        
        .btn-secondary {
            background-color: transparent;
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.5);
        }
        
        .btn-secondary:hover {
            background-color: rgba(255, 255, 255, 0.1);
            transform: translateY(-3px);
        }
        
        .instructions {
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            max-width: 800px;
            width: 100%;
        }
        
        .instructions h3 {
            margin-bottom: 10px;
            color: #FFD700;
        }
        
        .instructions ul {
            padding-left: 20px;
        }
        
        .instructions li {
            margin-bottom: 8px;
            line-height: 1.5;
        }
        
        .message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px 50px;
            border-radius: 15px;
            text-align: center;
            font-size: 2.5rem;
            font-weight: bold;
            z-index: 100;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            border: 3px solid #9370DB;
            width: 90%;
            max-width: 600px;
        }
        
        .message.show {
            transform: translate(-50%, -50%) scale(1);
        }
        
        .message-title {
            color: #FFD700;
            margin-bottom: 15px;
        }
        
        .message-stats {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 20px 0;
            font-size: 1.5rem;
        }
        
        .steps-count {
            color: #FFD700;
            font-size: 2rem;
            margin: 10px 0;
        }
        
        .stars-earned {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
        }
        
        .star-earned {
            font-size: 2rem;
            color: #ccc;
            transition: color 0.5s ease;
        }
        
        .star-earned.filled {
            color: #FFD700;
        }
        
        .message-actions {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 25px;
            flex-wrap: wrap;
        }
        
        .message-btn {
            padding: 12px 25px;
            font-size: 1.1rem;
        }
        
        .unlock-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        
        .unlock-animation.show {
            opacity: 1;
            display: flex;
        }
        
        .unlock-icon {
            font-size: 5rem;
            color: #FFD700;
            margin-bottom: 20px;
            animation: bounce 1s infinite alternate;
        }
        
        @keyframes bounce {
            from { transform: translateY(0); }
            to { transform: translateY(-20px); }
        }
        
        .unlock-text {
            font-size: 2.5rem;
            color: #FFD700;
            text-align: center;
            margin-bottom: 30px;
        }
        
        .unlock-level-name {
            font-size: 2rem;
            color: #9370DB;
            text-align: center;
            margin-bottom: 20px;
        }
        
        .footer {
            margin-top: 20px;
            text-align: center;
            font-size: 0.9rem;
            opacity: 0.7;
        }
        
        .first-time-hint {
            background-color: rgba(255, 215, 0, 0.2);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            text-align: center;
            border-left: 5px solid #FFD700;
            animation: fadeInOut 3s ease-in-out;
            display: none;
        }
        
        @keyframes fadeInOut {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 2.2rem;
            }
            
            .level-select-title {
                font-size: 1.8rem;
            }
            
            .stats {
                font-size: 1.2rem;
                padding: 12px 20px;
            }
            
            .mobile-controls {
                display: block;
            }
            
            .keyboard-controls {
                display: none;
            }
            
            .control-btn {
                width: 65px;
                height: 65px;
            }
            
            .game-header {
                flex-direction: column;
                gap: 15px;
            }
            
            .message {
                font-size: 2rem;
                padding: 20px 30px;
            }
            
            .steps-count {
                font-size: 2.5rem;
            }
            
            .message-actions {
                flex-direction: column;
                align-items: center;
            }
        }
        
        @media (max-width: 480px) {
            h1 {
                font-size: 1.8rem;
            }
            
            .level-select-title {
                font-size: 1.5rem;
            }
            
            .stats {
                flex-direction: column;
                align-items: center;
                gap: 8px;
            }
            
            .control-btn {
                width: 60px;
                height: 60px;
            }
            
            .btn {
                padding: 10px 20px;
                font-size: 1rem;
            }
            
            .message {
                font-size: 1.8rem;
                padding: 20px;
            }
            
            .steps-count {
                font-size: 2rem;
            }
            
            .level-card {
                padding: 15px;
            }
            
            .level-number {
                font-size: 2rem;
            }
        }
        
        .teleport-connection {
            position: absolute;
            pointer-events: none;
            z-index: 5;
        }
        
        .teleport-line {
            stroke: rgba(255, 105, 180, 0.6);
            stroke-width: 3;
            stroke-dasharray: 5;
            animation: dash 2s linear infinite;
        }
        
        @keyframes dash {
            to {
                stroke-dashoffset: -20;
            }
        }
        
        .teleport-info {
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
            font-size: 0.9rem;
            color: #FF69B4;
            border-left: 3px solid #FF69B4;
        }
        
        .cooldown-message {
            background-color: rgba(255, 0, 0, 0.7);
            border-radius: 8px;
            padding: 5px 10px;
            margin-top: 5px;
            font-size: 0.8rem;
            color: white;
            animation: fadeInOut 1s ease-in-out;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>–ú–∏–ª—ã–π –ö–æ—Ç–∏–∫ –≤ –õ–∞–±–∏—Ä–∏–Ω—Ç–µ</h1>
            <p class="subtitle">–ü–æ–º–æ–≥–∏ —Ñ–∏–æ–ª–µ—Ç–æ–≤–æ–º—É –∫–æ—Ç–∏–∫—É –Ω–∞–π—Ç–∏ –≤—ã—Ö–æ–¥ –∏–∑ –ª–∞–±–∏—Ä–∏–Ω—Ç–∞!</p>
        </header>
        
        <!-- –≠–∫—Ä–∞–Ω –≤—ã–±–æ—Ä–∞ —É—Ä–æ–≤–Ω–µ–π -->
        <div class="level-select-screen" id="levelSelectScreen">
            <h2 class="level-select-title">–í—ã–±–µ—Ä–∏—Ç–µ —É—Ä–æ–≤–µ–Ω—å</h2>
            <div class="levels-grid" id="levelsGrid">
                <!-- –£—Ä–æ–≤–Ω–∏ –±—É–¥—É—Ç –¥–æ–±–∞–≤–ª–µ–Ω—ã —á–µ—Ä–µ–∑ JavaScript -->
            </div>
            <div class="instructions">
                <h3>–ö–∞–∫ –∏–≥—Ä–∞—Ç—å:</h3>
                <ul>
                    <li>–ù–∞—á–∏–Ω–∞–π—Ç–µ —Å —É—Ä–æ–≤–Ω—è 1, —á—Ç–æ–±—ã —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å —Å–ª–µ–¥—É—é—â–∏–µ —É—Ä–æ–≤–Ω–∏</li>
                    <li>–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–ª–∞–≤–∏—à–∏ WASD –∏–ª–∏ —Å—Ç—Ä–µ–ª–∫–∏ –Ω–∞ —ç–∫—Ä–∞–Ω–µ, —á—Ç–æ–±—ã –¥–≤–∏–≥–∞—Ç—å –∫–æ—Ç–∏–∫–∞ –ø–æ –ª–∞–±–∏—Ä–∏–Ω—Ç—É</li>
                    <li>–ö–∞–∂–¥–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ –Ω–∞ –Ω–æ–≤—É—é –∫–ª–µ—Ç–∫—É = +1 —à–∞–≥</li>
                    <li>–û—Å—Ç–µ—Ä–µ–≥–∞–π—Ç–µ—Å—å –ª–æ–≤—É—à–µ–∫ (–æ—Ä–∞–Ω–∂–µ–≤—ã–µ) - –æ–Ω–∏ –±–ª–æ–∫–∏—Ä—É—é—Ç –¥–≤–∏–∂–µ–Ω–∏–µ –Ω–∞ 2 —Å–µ–∫—É–Ω–¥—ã</li>
                    <li><strong>–¢–µ–ª–µ–ø–æ—Ä—Ç—ã (—Ä–æ–∑–æ–≤—ã–µ, —Ñ–∏–æ–ª–µ—Ç–æ–≤—ã–µ, –∑–µ–ª–µ–Ω—ã–µ)</strong> - –¥–≤—É—Å—Ç–æ—Ä–æ–Ω–Ω–∏–µ –ø–æ—Ä—Ç–∞–ª—ã. –í–æ–π–¥–∏ –≤ –æ–¥–∏–Ω - –≤—ã–π–¥–∏ –∏–∑ –¥—Ä—É–≥–æ–≥–æ —Ç–æ–≥–æ –∂–µ —Ü–≤–µ—Ç–∞!</li>
                    <li><strong>–í–∞–∂–Ω–æ:</strong> –ü–æ—Å–ª–µ —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞—Ü–∏–∏ –µ—Å—Ç—å –Ω–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –±–µ—Å–∫–æ–Ω–µ—á–Ω—ã—Ö —Ü–∏–∫–ª–æ–≤</li>
                    <li>–û–¥–Ω–æ—Å—Ç–æ—Ä–æ–Ω–Ω–∏–µ –ø—É—Ç–∏ (—Å–∏–Ω–∏–µ) –ø–æ–∑–≤–æ–ª—è—é—Ç –¥–≤–∏–≥–∞—Ç—å—Å—è —Ç–æ–ª—å–∫–æ –≤ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ —Å—Ç—Ä–µ–ª–∫–∏</li>
                    <li>–ù–∞–π–¥–∏—Ç–µ –∑–µ–ª–µ–Ω—ã–π –≤—ã—Ö–æ–¥, —á—Ç–æ–±—ã –ø–æ–±–µ–¥–∏—Ç—å</li>
                    <li>–ü–æ—Å—Ç–∞—Ä–∞–π—Ç–µ—Å—å –ø—Ä–æ–π—Ç–∏ –ª–∞–±–∏—Ä–∏–Ω—Ç –∑–∞ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —à–∞–≥–æ–≤!</li>
                </ul>
                <div class="teleport-info">
                    <strong>–°–æ–≤–µ—Ç –ø–æ —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞–º:</strong> –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ç–µ–ª–µ–ø–æ—Ä—Ç—ã –∫–∞–∫ –∫–æ—Ä–æ—Ç–∫–∏–µ –ø—É—Ç–∏ –∏–ª–∏ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –º–∞—Ä—à—Ä—É—Ç—ã —á–µ—Ä–µ–∑ –ª–∞–±–∏—Ä–∏–Ω—Ç!
                </div>
            </div>
            <div id="firstTimeHint" class="first-time-hint">
                –ù–∞–∂–º–∏—Ç–µ –Ω–∞ —É—Ä–æ–≤–µ–Ω—å 1, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –∏–≥—Ä—É!
            </div>
        </div>
        
        <!-- –ò–≥—Ä–æ–≤–æ–π —ç–∫—Ä–∞–Ω -->
        <div class="game-screen" id="gameScreen">
            <div class="game-header">
                <div class="current-level-info">
                    <span>–£—Ä–æ–≤–µ–Ω—å <span id="currentLevelNumber">1</span>: <span id="currentLevelName">–ù–∞—á–∞–ª–æ –ø—É—Ç–∏</span></span>
                </div>
                <button id="backToLevelsBtn" class="back-to-levels">‚Üê –ö —É—Ä–æ–≤–Ω—è–º</button>
            </div>
            
            <div class="stats">
                <div>–°–æ—Å—Ç–æ—è–Ω–∏–µ: <span id="stateDisplay">–ì–æ—Ç–æ–≤</span></div>
                <div>–®–∞–≥–∏: <span id="steps" class="steps">0</span></div>
                <div>–í—Ä–µ–º—è: <span id="timerDisplay" class="timer">00:00</span></div>
            </div>
            
            <div class="game-wrapper">
                <canvas id="gameCanvas"></canvas>
                <div id="teleportConnections"></div>
                <div id="message" class="message">
                    <div class="message-title" id="messageTitle">–ü–æ–±–µ–¥–∞!</div>
                    <div class="message-stats">
                        <div>–£—Ä–æ–≤–µ–Ω—å: <span id="messageLevel">1</span></div>
                        <div class="steps-count">–®–∞–≥–æ–≤: <span id="finalSteps">0</span></div>
                        <div>–í—Ä–µ–º—è: <span id="finalTime">00:00</span></div>
                    </div>
                    <div class="stars-earned">
                        <div class="star-earned" id="star1">‚òÖ</div>
                        <div class="star-earned" id="star2">‚òÖ</div>
                        <div class="star-earned" id="star3">‚òÖ</div>
                    </div>
                    <div class="message-actions">
                        <button id="nextLevelBtn" class="btn btn-primary message-btn">–°–ª–µ–¥—É—é—â–∏–π —É—Ä–æ–≤–µ–Ω—å</button>
                        <button id="restartLevelBtn" class="btn btn-secondary message-btn">–ü–µ—Ä–µ–∏–≥—Ä–∞—Ç—å</button>
                        <button id="toLevelsBtn" class="btn btn-secondary message-btn">–ö —É—Ä–æ–≤–Ω—è–º</button>
                    </div>
                </div>
            </div>
            
            <div class="controls">
                <div class="keyboard-controls">
                    <h3>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ (–∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞)</h3>
                    <div class="keys">
                        <div class="key">W / –¶</div>
                        <div class="key">A / –§</div>
                        <div class="key">S / –´</div>
                        <div class="key">D / –í</div>
                    </div>
                </div>
                
                <div class="mobile-controls">
                    <h3>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ (–∫–∞—Å–∞–Ω–∏–µ)</h3>
                    <div class="control-buttons">
                        <button class="control-btn btn-up" id="upBtn">‚Üë</button>
                        <button class="control-btn btn-left" id="leftBtn">‚Üê</button>
                        <div class="btn-center"></div>
                        <button class="control-btn btn-right" id="rightBtn">‚Üí</button>
                        <button class="control-btn btn-down" id="downBtn">‚Üì</button>
                    </div>
                </div>
            </div>
            
            <div class="actions">
                <button id="newGameBtn" class="btn btn-primary">–ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ</button>
                <button id="hintBtn" class="btn btn-secondary">–ü–æ–¥—Å–∫–∞–∑–∫–∞</button>
                <button id="showTeleportsBtn" class="btn btn-secondary">–ü–æ–∫–∞–∑–∞—Ç—å —Ç–µ–ª–µ–ø–æ—Ä—Ç—ã</button>
            </div>
        </div>
        
        <!-- –ê–Ω–∏–º–∞—Ü–∏—è —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ —É—Ä–æ–≤–Ω—è -->
        <div class="unlock-animation" id="unlockAnimation">
            <div class="unlock-icon">üîì</div>
            <div class="unlock-text">–ù–û–í–´–ô –£–†–û–í–ï–ù–¨ –†–ê–ó–ë–õ–û–ö–ò–†–û–í–ê–ù!</div>
            <div class="unlock-level-name" id="unlockedLevelName">–£—Ä–æ–≤–µ–Ω—å 2</div>
            <button id="closeUnlockBtn" class="btn btn-primary" style="margin-top: 20px;">–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å</button>
        </div>
        
        <div class="footer">
            <p>–ò–≥—Ä–∞ —Å–æ–∑–¥–∞–Ω–∞ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º HTML5 Canvas –∏ —á–∏—Å—Ç–æ–≥–æ JavaScript</p>
        </div>
    </div>

    <script>
        // =============================================
        // –ö–û–ù–°–¢–ê–ù–¢–´ –ò –ü–ï–†–ï–ú–ï–ù–ù–´–ï
        // =============================================
        
        // –°–æ—Å—Ç–æ—è–Ω–∏—è –∏–≥—Ä—ã
        const GAME_STATES = {
            IDLE: 'idle',
            MOVING: 'moving',
            WIN: 'win',
            TRAPPED: 'trapped',
            TELEPORTING: 'teleporting',
            TELEPORT_COOLDOWN: 'teleport_cooldown'  // –ù–æ–≤–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ - –∑–∞—â–∏—Ç–∞ –æ—Ç –ø–æ–≤—Ç–æ—Ä–Ω–æ–π —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞—Ü–∏–∏
        };

        // –†–∞–∑–º–µ—Ä—ã –ª–∞–±–∏—Ä–∏–Ω—Ç–∞ (–≤ –∫–ª–µ—Ç–∫–∞—Ö)
        const MAZE_SIZE = 15;

        // –¶–≤–µ—Ç–∞
        const COLORS = {
            CAT_MAIN: '#9370DB',
            CAT_ACCENT: '#8A2BE2',
            CAT_EAR_INNER: '#FFB6C1',
            MAZE_WALL: '#555',
            EXIT: '#32CD32',
            START: '#9370DB',
            PATH: '#3A3A4A',
            TEXT: '#FFFFFF',
            HINT: 'rgba(255, 215, 0, 0.3)',
            TRAP: '#FF4500',
            TELEPORT_A: '#FF69B4',
            TELEPORT_B: '#9370DB',
            TELEPORT_C: '#32CD32',
            ONE_WAY: '#4682B4'
        };

        // –ö–æ–¥—ã –∫–ª–µ—Ç–æ–∫ –ª–∞–±–∏—Ä–∏–Ω—Ç–∞
        const CELL_TYPES = {
            WALL: 1,
            PATH: 0,
            START: 2,
            EXIT: 3,
            TRAP: 4,
            TELEPORT_A: 5,
            TELEPORT_B: 6,
            TELEPORT_C: 7,
            ONE_WAY_UP: 8,
            ONE_WAY_RIGHT: 9,
            ONE_WAY_DOWN: 10,
            ONE_WAY_LEFT: 11
        };

        // =============================================
        // –î–ê–ù–ù–´–ï –£–†–û–í–ù–ï–ô –° –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ú–ò –¢–ï–õ–ï–ü–û–†–¢–ê–ú–ò
        // =============================================
        
        const LEVELS = [
            {
                id: 1,
                name: "–ù–∞—á–∞–ª–æ –ø—É—Ç–∏",
                description: "–ü—Ä–æ—Å—Ç–µ–π—à–∏–π –ª–∞–±–∏—Ä–∏–Ω—Ç –¥–ª—è –∑–Ω–∞–∫–æ–º—Å—Ç–≤–∞",
                maze: [
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1],
                    [1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1],
                    [1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
                    [1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1],
                    [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1],
                    [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
                    [1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1],
                    [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
                ],
                unlocked: true,
                bestScore: 0,
                stars: 0,
                time: 0,
                teleportPairs: []
            },
            {
                id: 2,
                name: "–ü—Ä–æ—Å—Ç—ã–µ —Ç–µ–ª–µ–ø–æ—Ä—Ç—ã",
                description: "–ü—Ä–æ—Å—Ç—ã–µ –¥–≤—É—Å—Ç–æ—Ä–æ–Ω–Ω–∏–µ —Ç–µ–ª–µ–ø–æ—Ä—Ç—ã –¥–ª—è –∫–æ—Ä–æ—Ç–∫–∏—Ö –ø—É—Ç–µ–π",
                maze: [
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1],
                    [1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1],
                    [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 4, 0, 1],
                    [1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1],
                    [1, 0, 0, 0, 1, 0, 5, 0, 1, 0, 0, 0, 0, 0, 1],
                    [1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1],
                    [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
                    [1, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 3, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
                ],
                unlocked: false,
                bestScore: 0,
                stars: 0,
                time: 0,
                teleportPairs: [
                    { type: 'A', positions: [{x: 6, y: 9}, {x: 5, y: 13}] }
                ]
            },
            {
                id: 3,
                name: "–¢–µ–ª–µ–ø–æ—Ä—Ç—ã –∏ –ª–æ–≤—É—à–∫–∏",
                description: "–î–æ–±–∞–≤–ª–µ–Ω—ã –ª–æ–≤—É—à–∫–∏ –∏ —Ç–µ–ª–µ–ø–æ—Ä—Ç—ã –∫–∞–∫ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –ø—É—Ç—å",
                maze: [
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 2, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                    [1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1],
                    [1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1],
                    [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1],
                    [1, 0, 0, 0, 0, 0, 0, 4, 0, 0, 5, 0, 0, 0, 1],
                    [1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1],
                    [1, 0, 0, 0, 0, 4, 1, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
                    [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
                    [1, 0, 0, 0, 0, 6, 0, 0, 0, 6, 0, 0, 0, 3, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
                ],
                unlocked: false,
                bestScore: 0,
                stars: 0,
                time: 0,
                teleportPairs: [
                    { type: 'A', positions: [{x: 10, y: 5}, {x: 5, y: 13}] },
                    { type: 'B', positions: [{x: 5, y: 13}, {x: 9, y: 13}] }  // –ò–°–ü–†–ê–í–õ–ï–ù–û: —Ä–∞–∑–¥–µ–ª–∏–ª —Ç–µ–ª–µ–ø–æ—Ä—Ç—ã B
                ]
            },
            {
                id: 4,
                name: "–°–ª–æ–∂–Ω–∞—è —Å–µ—Ç—å —Ç–µ–ª–µ–ø–æ—Ä—Ç–æ–≤",
                description: "–ù–µ—Å–∫–æ–ª—å–∫–æ —Ç–µ–ª–µ–ø–æ—Ä—Ç–æ–≤ –¥–ª—è —Å—Ç—Ä–∞—Ç–µ–≥–∏—á–µ—Å–∫–æ–≥–æ –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è",
                maze: [
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 2, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
                    [1, 6, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 3, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
                ],
                unlocked: false,
                bestScore: 0,
                stars: 0,
                time: 0,
                teleportPairs: [
                    { type: 'A', positions: [{x: 7, y: 1}, {x: 8, y: 13}] },
                    { type: 'B', positions: [{x: 5, y: 7}, {x: 1, y: 13}] }
                ]
            },
            {
                id: 5,
                name: "–ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å",
                description: "–í—Å–µ —Ç–∏–ø—ã –ª–æ–≤—É—à–µ–∫ –∏ —Ç–µ–ª–µ–ø–æ—Ä—Ç–æ–≤ –≤–º–µ—Å—Ç–µ",
                maze: [
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
                    [1, 0, 4, 0, 0, 5, 0, 0, 0, 4, 0, 0, 0, 0, 1],
                    [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
                    [1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 7, 0, 3, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
                ],
                unlocked: false,
                bestScore: 0,
                stars: 0,
                time: 0,
                teleportPairs: [
                    { type: 'A', positions: [{x: 5, y: 7}, {x: 7, y: 13}] },
                    { type: 'B', positions: [{x: 5, y: 11}, {x: 11, y: 13}] },
                    { type: 'C', positions: [{x: 7, y: 13}, {x: 11, y: 13}] }
                ]
            },
            {
                id: 6,
                name: "–ú–∞—Å—Ç–µ—Ä –ª–∞–±–∏—Ä–∏–Ω—Ç–æ–≤",
                description: "–°–∞–º—ã–π —Å–ª–æ–∂–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å —Å–æ –≤—Å–µ–º–∏ –º–µ—Ö–∞–Ω–∏–∫–∞–º–∏",
                maze: [
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 2, 0, 0, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 1],
                    [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1],
                    [1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1],
                    [1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1],
                    [1, 0, 0, 1, 0, 5, 0, 0, 0, 1, 0, 0, 0, 0, 1],
                    [1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
                    [1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1],
                    [1, 0, 4, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1],
                    [1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1],
                    [1, 0, 0, 1, 0, 6, 0, 0, 7, 0, 0, 0, 0, 3, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
                ],
                unlocked: false,
                bestScore: 0,
                stars: 0,
                time: 0,
                teleportPairs: [
                    { type: 'A', positions: [{x: 5, y: 5}, {x: 8, y: 13}] },
                    { type: 'B', positions: [{x: 5, y: 13}, {x: 8, y: 13}] },  // –ò–°–ü–†–ê–í–õ–ï–ù–û: –∏–∑–º–µ–Ω–µ–Ω–∞ –ø–æ–∑–∏—Ü–∏—è
                    { type: 'C', positions: [{x: 5, y: 5}, {x: 8, y: 13}] }   // –ò–°–ü–†–ê–í–õ–ï–ù–û: –∏–∑–º–µ–Ω–µ–Ω–∞ –ø–æ–∑–∏—Ü–∏—è
                ]
            }
        ];

        // –ü–æ—Ä–æ–≥–∏ –¥–ª—è –∑–≤–µ–∑–¥ (–≤ —à–∞–≥–∞—Ö)
        const STAR_THRESHOLDS = {
            1: {1: 30, 2: 35, 3: 40, 4: 35, 5: 50, 6: 60},
            2: {1: 25, 2: 30, 3: 35, 4: 30, 5: 45, 6: 55},
            3: {1: 20, 2: 25, 3: 30, 4: 25, 5: 40, 6: 50}
        };

        // –ò–≥—Ä–æ–≤—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        let canvas, ctx;
        let cellSize = 32;
        let gameState = GAME_STATES.IDLE;
        let catGridPos = {x: 1, y: 1};
        let catPixelPos = {x: 0, y: 0};
        let steps = 0;
        let animationStartTime = 0;
        let animationDuration = 200;
        let moveDirection = null;
        let targetGridPos = null;
        let exitPos = {x: 13, y: 13};
        let hintVisible = false;
        let showTeleportConnections = false;
        let currentLevel = 0;
        let gameStartTime = 0;
        let gameTime = 0;
        let timerInterval = null;
        let currentMaze = [];
        let teleportPairs = [];
        
        // –ù–æ–≤—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –∑–∞—â–∏—Ç—ã –æ—Ç –±–µ—Å–∫–æ–Ω–µ—á–Ω—ã—Ö —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞—Ü–∏–π
        let lastTeleportTime = 0;
        let teleportCooldown = 1000; // 1 —Å–µ–∫—É–Ω–¥–∞ –∑–∞–¥–µ—Ä–∂–∫–∏ –º–µ–∂–¥—É —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞–º–∏
        let lastTeleportPosition = null;

        // –≠–ª–µ–º–µ–Ω—Ç—ã DOM
        let levelSelectScreen, gameScreen;
        let levelsGrid;
        let stepsDisplay, stateDisplay, timerDisplay, messageElement;
        let messageTitle, messageLevel, finalStepsDisplay, finalTimeDisplay;
        let star1, star2, star3;
        let restartBtn, newGameBtn, hintBtn, nextLevelBtn, toLevelsBtn, restartLevelBtn;
        let upBtn, downBtn, leftBtn, rightBtn;
        let backToLevelsBtn;
        let currentLevelNumber, currentLevelName;
        let unlockAnimation, unlockedLevelName, closeUnlockBtn;
        let firstTimeHint;
        let showTeleportsBtn;
        let teleportConnectionsElement;

        // =============================================
        // –§–£–ù–ö–¶–ò–ò –£–ü–†–ê–í–õ–ï–ù–ò–Ø –£–†–û–í–ù–Ø–ú–ò
        // =============================================
        
        function loadProgress() {
            const savedProgress = localStorage.getItem('catMazeProgress');
            if (savedProgress) {
                try {
                    const progress = JSON.parse(savedProgress);
                    
                    for (let i = 0; i < LEVELS.length; i++) {
                        if (progress[i]) {
                            LEVELS[i].unlocked = progress[i].unlocked || false;
                            LEVELS[i].bestScore = progress[i].bestScore || 0;
                            LEVELS[i].stars = progress[i].stars || 0;
                            LEVELS[i].time = progress[i].time || 0;
                        }
                    }
                } catch (e) {
                    console.log("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å, –Ω–∞—á–∏–Ω–∞—è —Å –Ω–∞—á–∞–ª–∞");
                }
            }
            
            LEVELS[0].unlocked = true;
        }

        function saveProgress() {
            const progress = LEVELS.map(level => ({
                unlocked: level.unlocked,
                bestScore: level.bestScore,
                stars: level.stars,
                time: level.time
            }));
            
            localStorage.setItem('catMazeProgress', JSON.stringify(progress));
        }

        function showLevelSelect() {
            if (levelSelectScreen) levelSelectScreen.style.display = 'flex';
            if (gameScreen) gameScreen.style.display = 'none';
            if (unlockAnimation) unlockAnimation.style.display = 'none';
            renderLevels();
            
            if (isFirstVisit() && firstTimeHint) {
                setTimeout(() => {
                    firstTimeHint.style.display = 'block';
                    setTimeout(() => {
                        firstTimeHint.style.display = 'none';
                    }, 5000);
                }, 1000);
            }
        }

        function isFirstVisit() {
            const visited = localStorage.getItem('catMazeVisited');
            if (!visited) {
                localStorage.setItem('catMazeVisited', 'true');
                return true;
            }
            return false;
        }

        function renderLevels() {
            if (!levelsGrid) return;
            
            levelsGrid.innerHTML = '';
            
            LEVELS.forEach(level => {
                const levelCard = document.createElement('div');
                levelCard.className = `level-card ${level.unlocked ? 'unlocked' : 'locked'}`;
                levelCard.dataset.levelId = level.id;
                
                if (level.unlocked && level.id > 1 && level.bestScore === 0) {
                    levelCard.classList.add('new');
                }
                
                levelCard.innerHTML = `
                    ${level.unlocked ? 
                        `<div class="level-number">${level.id}</div>` : 
                        `<div class="lock-icon">üîí</div>`
                    }
                    <div class="level-name">${level.name}</div>
                    <div class="level-description">${level.description}</div>
                    <div class="level-stats">
                        ${level.bestScore > 0 ? 
                            `<div class="best-score">–õ—É—á—à–∏–π: ${level.bestScore} —à–∞–≥–æ–≤</div>` : 
                            `<div class="best-score">–ù–µ –ø—Ä–æ–π–¥–µ–Ω</div>`
                        }
                        <div class="stars">
                            <div class="star ${level.stars >= 1 ? 'filled' : ''}">‚òÖ</div>
                            <div class="star ${level.stars >= 2 ? 'filled' : ''}">‚òÖ</div>
                            <div class="star ${level.stars >= 3 ? 'filled' : ''}">‚òÖ</div>
                        </div>
                    </div>
                    ${level.unlocked && level.id === currentLevel ? 
                        `<div class="current-level-indicator">üò∫</div>` : ''
                    }
                `;
                
                if (level.unlocked) {
                    levelCard.addEventListener('click', () => startLevel(level.id));
                }
                
                levelsGrid.appendChild(levelCard);
            });
        }

        function startLevel(levelId) {
            currentLevel = levelId;
            const level = LEVELS[levelId - 1];
            
            if (currentLevelNumber) currentLevelNumber.textContent = level.id;
            if (currentLevelName) currentLevelName.textContent = level.name;
            if (messageLevel) messageLevel.textContent = level.id;
            
            currentMaze = JSON.parse(JSON.stringify(level.maze));
            teleportPairs = level.teleportPairs || [];
            
            findStartPosition();
            findExitPosition();
            
            resetGameVariables();
            
            if (levelSelectScreen) levelSelectScreen.style.display = 'none';
            if (gameScreen) gameScreen.style.display = 'flex';
            if (unlockAnimation) unlockAnimation.style.display = 'none';
            
            startTimer();
            updateUI();
            drawTeleportConnections();
            resizeCanvas();
            
            console.log(`–ù–∞—á–∞—Ç —É—Ä–æ–≤–µ–Ω—å ${levelId} —Å ${teleportPairs.length} –ø–∞—Ä–∞–º–∏ —Ç–µ–ª–µ–ø–æ—Ä—Ç–æ–≤`);
        }

        function drawTeleportConnections() {
            if (!teleportConnectionsElement) return;
            
            teleportConnectionsElement.innerHTML = '';
            
            if (!showTeleportConnections) return;
            
            teleportPairs.forEach(pair => {
                if (pair.positions.length >= 2) {
                    const svgNS = "http://www.w3.org/2000/svg";
                    const svg = document.createElementNS(svgNS, "svg");
                    svg.classList.add('teleport-connection');
                    
                    svg.setAttribute('width', canvas.width);
                    svg.setAttribute('height', canvas.height);
                    svg.style.position = 'absolute';
                    svg.style.top = '0';
                    svg.style.left = '0';
                    svg.style.pointerEvents = 'none';
                    
                    for (let i = 0; i < pair.positions.length - 1; i++) {
                        for (let j = i + 1; j < pair.positions.length; j++) {
                            const pos1 = pair.positions[i];
                            const pos2 = pair.positions[j];
                            
                            const x1 = pos1.x * cellSize + cellSize / 2;
                            const y1 = pos1.y * cellSize + cellSize / 2;
                            const x2 = pos2.x * cellSize + cellSize / 2;
                            const y2 = pos2.y * cellSize + cellSize / 2;
                            
                            const line = document.createElementNS(svgNS, "line");
                            line.classList.add('teleport-line');
                            line.setAttribute('x1', x1);
                            line.setAttribute('y1', y1);
                            line.setAttribute('x2', x2);
                            line.setAttribute('y2', y2);
                            
                            let color;
                            switch(pair.type) {
                                case 'A': color = COLORS.TELEPORT_A; break;
                                case 'B': color = COLORS.TELEPORT_B; break;
                                case 'C': color = COLORS.TELEPORT_C; break;
                                default: color = COLORS.TELEPORT_A;
                            }
                            
                            line.setAttribute('stroke', color);
                            line.setAttribute('stroke-opacity', '0.6');
                            line.setAttribute('stroke-width', '3');
                            line.setAttribute('stroke-dasharray', '5');
                            
                            svg.appendChild(line);
                        }
                    }
                    
                    teleportConnectionsElement.appendChild(svg);
                }
            });
        }

        function findExitPosition() {
            for (let y = 0; y < MAZE_SIZE; y++) {
                for (let x = 0; x < MAZE_SIZE; x++) {
                    if (currentMaze[y][x] === CELL_TYPES.EXIT) {
                        exitPos = {x, y};
                        return;
                    }
                }
            }
            exitPos = {x: 13, y: 13};
        }

        function resetGameVariables() {
            gameState = GAME_STATES.IDLE;
            steps = 0;
            moveDirection = null;
            hintVisible = false;
            gameTime = 0;
            showTeleportConnections = false;
            lastTeleportTime = 0;
            lastTeleportPosition = null;
            
            findStartPosition();
            
            catPixelPos.x = catGridPos.x * cellSize;
            catPixelPos.y = catGridPos.y * cellSize;
            
            if (messageElement) messageElement.classList.remove('show');
            
            if (showTeleportsBtn) {
                showTeleportsBtn.textContent = "–ü–æ–∫–∞–∑–∞—Ç—å —Ç–µ–ª–µ–ø–æ—Ä—Ç—ã";
            }
        }

        function startTimer() {
            gameStartTime = Date.now();
            
            if (timerInterval) {
                clearInterval(timerInterval);
            }
            
            timerInterval = setInterval(() => {
                gameTime = Math.floor((Date.now() - gameStartTime) / 1000);
                updateTimerDisplay();
            }, 1000);
        }

        function updateTimerDisplay() {
            if (!timerDisplay) return;
            const minutes = Math.floor(gameTime / 60);
            const seconds = gameTime % 60;
            timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function completeLevel() {
            stopTimer();
            gameState = GAME_STATES.WIN;
            
            const level = LEVELS[currentLevel - 1];
            const starsEarned = calculateStars(steps, currentLevel);
            
            if (level.bestScore === 0 || steps < level.bestScore) {
                level.bestScore = steps;
                level.stars = starsEarned;
                level.time = gameTime;
            } else if (steps === level.bestScore && starsEarned > level.stars) {
                level.stars = starsEarned;
            }
            
            saveProgress();
            
            if (currentLevel < LEVELS.length) {
                const nextLevel = LEVELS[currentLevel];
                if (!nextLevel.unlocked) {
                    nextLevel.unlocked = true;
                    saveProgress();
                    
                    showUnlockAnimation(currentLevel + 1);
                }
            }
            
            showWinMessage(starsEarned);
        }

        function calculateStars(steps, levelId) {
            if (steps <= STAR_THRESHOLDS[3][levelId]) return 3;
            if (steps <= STAR_THRESHOLDS[2][levelId]) return 2;
            if (steps <= STAR_THRESHOLDS[1][levelId]) return 1;
            return 0;
        }

        function showUnlockAnimation(levelId) {
            const level = LEVELS[levelId - 1];
            if (unlockedLevelName) unlockedLevelName.textContent = `–£—Ä–æ–≤–µ–Ω—å ${levelId}: ${level.name}`;
            if (unlockAnimation) {
                unlockAnimation.style.display = 'flex';
                setTimeout(() => {
                    unlockAnimation.classList.add('show');
                }, 10);
            }
            
            if (navigator.vibrate) {
                navigator.vibrate([100, 50, 100]);
            }
        }

        function showWinMessage(starsEarned) {
            if (!messageTitle || !finalStepsDisplay || !finalTimeDisplay) return;
            
            messageTitle.textContent = "–£—Ä–æ–≤–µ–Ω—å –ø—Ä–æ–π–¥–µ–Ω!";
            finalStepsDisplay.textContent = steps;
            
            const minutes = Math.floor(gameTime / 60);
            const seconds = gameTime % 60;
            finalTimeDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            if (star1 && star2 && star3) {
                star1.classList.remove('filled');
                star2.classList.remove('filled');
                star3.classList.remove('filled');
                
                setTimeout(() => {
                    if (starsEarned >= 1) star1.classList.add('filled');
                }, 300);
                
                setTimeout(() => {
                    if (starsEarned >= 2) star2.classList.add('filled');
                }, 600);
                
                setTimeout(() => {
                    if (starsEarned >= 3) star3.classList.add('filled');
                }, 900);
            }
            
            if (nextLevelBtn) {
                if (currentLevel < LEVELS.length) {
                    nextLevelBtn.style.display = 'block';
                } else {
                    nextLevelBtn.style.display = 'none';
                }
            }
            
            setTimeout(() => {
                if (messageElement) messageElement.classList.add('show');
            }, 500);
        }

        // =============================================
        // –û–°–ù–û–í–ù–´–ï –§–£–ù–ö–¶–ò–ò –ò–ì–†–´
        // =============================================
        
        function init() {
            console.log("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä—ã...");
            
            canvas = document.getElementById('gameCanvas');
            if (!canvas) {
                console.error("Canvas –Ω–µ –Ω–∞–π–¥–µ–Ω!");
                return;
            }
            ctx = canvas.getContext('2d');
            
            levelSelectScreen = document.getElementById('levelSelectScreen');
            gameScreen = document.getElementById('gameScreen');
            levelsGrid = document.getElementById('levelsGrid');
            teleportConnectionsElement = document.getElementById('teleportConnections');
            
            stepsDisplay = document.getElementById('steps');
            stateDisplay = document.getElementById('stateDisplay');
            timerDisplay = document.getElementById('timerDisplay');
            messageElement = document.getElementById('message');
            messageTitle = document.getElementById('messageTitle');
            messageLevel = document.getElementById('messageLevel');
            finalStepsDisplay = document.getElementById('finalSteps');
            finalTimeDisplay = document.getElementById('finalTime');
            
            star1 = document.getElementById('star1');
            star2 = document.getElementById('star2');
            star3 = document.getElementById('star3');
            
            restartBtn = document.getElementById('newGameBtn');
            newGameBtn = document.getElementById('newGameBtn');
            hintBtn = document.getElementById('hintBtn');
            nextLevelBtn = document.getElementById('nextLevelBtn');
            toLevelsBtn = document.getElementById('toLevelsBtn');
            restartLevelBtn = document.getElementById('restartLevelBtn');
            showTeleportsBtn = document.getElementById('showTeleportsBtn');
            
            upBtn = document.getElementById('upBtn');
            downBtn = document.getElementById('downBtn');
            leftBtn = document.getElementById('leftBtn');
            rightBtn = document.getElementById('rightBtn');
            
            backToLevelsBtn = document.getElementById('backToLevelsBtn');
            
            currentLevelNumber = document.getElementById('currentLevelNumber');
            currentLevelName = document.getElementById('currentLevelName');
            
            unlockAnimation = document.getElementById('unlockAnimation');
            unlockedLevelName = document.getElementById('unlockedLevelName');
            closeUnlockBtn = document.getElementById('closeUnlockBtn');
            
            firstTimeHint = document.getElementById('firstTimeHint');
            
            console.log("–≠–ª–µ–º–µ–Ω—Ç—ã DOM –∑–∞–≥—Ä—É–∂–µ–Ω—ã");
            
            loadProgress();
            setupEventListeners();
            showLevelSelect();
            requestAnimationFrame(gameLoop);
            
            console.log("–ò–≥—Ä–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞");
        }

        function findStartPosition() {
            if (!currentMaze || currentMaze.length === 0) {
                console.error("–õ–∞–±–∏—Ä–∏–Ω—Ç –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω!");
                return;
            }
            
            for (let y = 0; y < MAZE_SIZE; y++) {
                for (let x = 0; x < MAZE_SIZE; x++) {
                    if (currentMaze[y][x] === CELL_TYPES.START) {
                        catGridPos.x = x;
                        catGridPos.y = y;
                        return;
                    }
                }
            }
            catGridPos.x = 1;
            catGridPos.y = 1;
        }

        function setupEventListeners() {
            console.log("–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ —Å–æ–±—ã—Ç–∏–π...");
            
            document.addEventListener('keydown', handleKeyDown);
            
            if (upBtn) upBtn.addEventListener('click', () => moveCat('up'));
            if (downBtn) downBtn.addEventListener('click', () => moveCat('down'));
            if (leftBtn) leftBtn.addEventListener('click', () => moveCat('left'));
            if (rightBtn) rightBtn.addEventListener('click', () => moveCat('right'));
            
            if (restartBtn) restartBtn.addEventListener('click', () => startLevel(currentLevel));
            if (hintBtn) hintBtn.addEventListener('click', toggleHint);
            if (showTeleportsBtn) showTeleportsBtn.addEventListener('click', toggleTeleportConnections);
            if (nextLevelBtn) nextLevelBtn.addEventListener('click', () => {
                if (currentLevel < LEVELS.length) {
                    if (messageElement) messageElement.classList.remove('show');
                    setTimeout(() => startLevel(currentLevel + 1), 300);
                }
            });
            if (toLevelsBtn) toLevelsBtn.addEventListener('click', () => {
                if (messageElement) messageElement.classList.remove('show');
                setTimeout(showLevelSelect, 300);
            });
            if (restartLevelBtn) restartLevelBtn.addEventListener('click', () => {
                if (messageElement) messageElement.classList.remove('show');
                setTimeout(() => startLevel(currentLevel), 300);
            });
            
            if (backToLevelsBtn) backToLevelsBtn.addEventListener('click', showLevelSelect);
            
            if (closeUnlockBtn) closeUnlockBtn.addEventListener('click', () => {
                if (unlockAnimation) {
                    unlockAnimation.classList.remove('show');
                    setTimeout(() => {
                        unlockAnimation.style.display = 'none';
                        showLevelSelect();
                    }, 500);
                }
            });
            
            window.addEventListener('resize', resizeCanvas);
            
            console.log("–û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã");
        }

        function toggleTeleportConnections() {
            showTeleportConnections = !showTeleportConnections;
            
            if (showTeleportsBtn) {
                showTeleportsBtn.textContent = showTeleportConnections ? 
                    "–°–∫—Ä—ã—Ç—å —Ç–µ–ª–µ–ø–æ—Ä—Ç—ã" : "–ü–æ–∫–∞–∑–∞—Ç—å —Ç–µ–ª–µ–ø–æ—Ä—Ç—ã";
            }
            
            drawTeleportConnections();
        }

        function handleKeyDown(e) {
            if (gameState === GAME_STATES.WIN || gameState === GAME_STATES.TRAPPED || 
                gameState === GAME_STATES.TELEPORTING || gameState === GAME_STATES.TELEPORT_COOLDOWN) return;
            
            switch(e.key.toLowerCase()) {
                case 'w':
                case '—Ü':
                case 'arrowup':
                    moveCat('up');
                    break;
                case 'a':
                case '—Ñ':
                case 'arrowleft':
                    moveCat('left');
                    break;
                case 's':
                case '—ã':
                case 'arrowdown':
                    moveCat('down');
                    break;
                case 'd':
                case '–≤':
                case 'arrowright':
                    moveCat('right');
                    break;
                case 't':
                case '–µ':
                    toggleTeleportConnections();
                    break;
            }
        }

        function moveCat(direction) {
            if (gameState === GAME_STATES.MOVING || gameState === GAME_STATES.WIN || 
                gameState === GAME_STATES.TRAPPED || gameState === GAME_STATES.TELEPORTING || 
                gameState === GAME_STATES.TELEPORT_COOLDOWN) {
                return;
            }
            
            targetGridPos = {x: catGridPos.x, y: catGridPos.y};
            
            switch(direction) {
                case 'up':
                    targetGridPos.y--;
                    break;
                case 'down':
                    targetGridPos.y++;
                    break;
                case 'left':
                    targetGridPos.x--;
                    break;
                case 'right':
                    targetGridPos.x++;
                    break;
            }
            
            if (isMoveValid(targetGridPos.x, targetGridPos.y, direction)) {
                moveDirection = direction;
                gameState = GAME_STATES.MOVING;
                animationStartTime = Date.now();
                steps++;
                updateUI();
            }
        }

        function isMoveValid(x, y, direction) {
            if (x < 0 || x >= MAZE_SIZE || y < 0 || y >= MAZE_SIZE) {
                return false;
            }
            
            const cellType = currentMaze[y][x];
            
            if (cellType === CELL_TYPES.WALL) {
                return false;
            }
            
            if (direction) {
                switch(cellType) {
                    case CELL_TYPES.ONE_WAY_UP:
                        if (direction !== 'up') return false;
                        break;
                    case CELL_TYPES.ONE_WAY_RIGHT:
                        if (direction !== 'right') return false;
                        break;
                    case CELL_TYPES.ONE_WAY_DOWN:
                        if (direction !== 'down') return false;
                        break;
                    case CELL_TYPES.ONE_WAY_LEFT:
                        if (direction !== 'left') return false;
                        break;
                }
            }
            
            return true;
        }

        function updateCatPosition() {
            const currentTime = Date.now();
            const elapsed = currentTime - animationStartTime;
            const progress = Math.min(elapsed / animationDuration, 1);
            
            const startX = catGridPos.x * cellSize;
            const startY = catGridPos.y * cellSize;
            const targetX = targetGridPos.x * cellSize;
            const targetY = targetGridPos.y * cellSize;
            
            const easeProgress = 1 - (1 - progress) * (1 - progress);
            
            catPixelPos.x = startX + (targetX - startX) * easeProgress;
            catPixelPos.y = startY + (targetY - startY) * easeProgress;
            
            if (progress >= 1) {
                catGridPos.x = targetGridPos.x;
                catGridPos.y = targetGridPos.y;
                
                const cellType = currentMaze[catGridPos.y][catGridPos.x];
                
                switch(cellType) {
                    case CELL_TYPES.EXIT:
                        completeLevel();
                        break;
                        
                    case CELL_TYPES.TRAP:
                        activateTrap();
                        break;
                        
                    case CELL_TYPES.TELEPORT_A:
                    case CELL_TYPES.TELEPORT_B:
                    case CELL_TYPES.TELEPORT_C:
                        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—É–ª–¥–∞—É–Ω –ø–µ—Ä–µ–¥ —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞—Ü–∏–µ–π
                        const now = Date.now();
                        if (now - lastTeleportTime < teleportCooldown) {
                            // –ï—Å–ª–∏ –∫—É–ª–¥–∞—É–Ω –µ—â–µ –¥–µ–π—Å—Ç–≤—É–µ—Ç, –ø—Ä–æ—Å—Ç–æ –æ—Å—Ç–∞–µ–º—Å—è –Ω–∞ –º–µ—Å—Ç–µ
                            gameState = GAME_STATES.IDLE;
                            showCooldownMessage();
                        } else {
                            activateTeleport(cellType);
                        }
                        break;
                        
                    default:
                        gameState = GAME_STATES.IDLE;
                }
                
                moveDirection = null;
                updateUI();
            }
        }

        // –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –¢–ï–õ–ï–ü–û–†–¢–ê–¶–ò–ò –° –ó–ê–©–ò–¢–û–ô –û–¢ –¶–ò–ö–õ–û–í
        function activateTeleport(teleportType) {
            gameState = GAME_STATES.TELEPORTING;
            if (stateDisplay) stateDisplay.textContent = "–¢–µ–ª–µ–ø–æ—Ä—Ç–∞—Ü–∏—è!";
            
            // –ó–∞–ø–æ–º–∏–Ω–∞–µ–º –≤—Ä–µ–º—è —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞—Ü–∏–∏
            lastTeleportTime = Date.now();
            
            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞ (A, B –∏–ª–∏ C)
            const teleportTypeChar = String.fromCharCode(65 + (teleportType - CELL_TYPES.TELEPORT_A));
            
            // –ù–∞—Ö–æ–¥–∏–º –ø–∞—Ä—É —Ç–µ–ª–µ–ø–æ—Ä—Ç–æ–≤ –¥–ª—è —ç—Ç–æ–≥–æ —Ç–∏–ø–∞
            const pair = teleportPairs.find(p => p.type === teleportTypeChar);
            
            if (!pair || pair.positions.length < 2) {
                gameState = GAME_STATES.IDLE;
                return;
            }
            
            // –ù–∞—Ö–æ–¥–∏–º —Ç–µ–∫—É—â—É—é –ø–æ–∑–∏—Ü–∏—é –∫–æ—Ç–∞
            const currentPos = {x: catGridPos.x, y: catGridPos.y};
            
            // –ò—â–µ–º –ø–∞—Ä–Ω—ã–π —Ç–µ–ª–µ–ø–æ—Ä—Ç
            let targetPos = null;
            
            // –ü–µ—Ä–µ–±–∏—Ä–∞–µ–º –≤—Å–µ —Ç–µ–ª–µ–ø–æ—Ä—Ç—ã —ç—Ç–æ–≥–æ —Ç–∏–ø–∞
            for (const pos of pair.positions) {
                // –ï—Å–ª–∏ —ç—Ç–æ –Ω–µ —Ç–µ–∫—É—â–∞—è –ø–æ–∑–∏—Ü–∏—è –∫–æ—Ç–∞
                if (pos.x !== currentPos.x || pos.y !== currentPos.y) {
                    targetPos = pos;
                    break;
                }
            }
            
            // –ï—Å–ª–∏ –Ω–∞—à–ª–∏ —Ü–µ–ª–µ–≤–æ–π —Ç–µ–ª–µ–ø–æ—Ä—Ç
            if (targetPos) {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –¥–æ—Å—Ç—É–ø–Ω–∞ –ª–∏ —Ü–µ–ª–µ–≤–∞—è –∫–ª–µ—Ç–∫–∞ (–Ω–µ —Å—Ç–µ–Ω–∞)
                if (currentMaze[targetPos.y][targetPos.x] !== CELL_TYPES.WALL) {
                    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ü–µ–ª–µ–≤—É—é –ø–æ–∑–∏—Ü–∏—é
                    targetGridPos = {x: targetPos.x, y: targetPos.y};
                    
                    // –ó–∞–ø–æ–º–∏–Ω–∞–µ–º –ø–æ–∑–∏—Ü–∏—é —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞—Ü–∏–∏ –¥–ª—è –∑–∞—â–∏—Ç—ã –æ—Ç —Ü–∏–∫–ª–æ–≤
                    lastTeleportPosition = {x: currentPos.x, y: currentPos.y};
                    
                    // –ó–∞–ø—É—Å–∫–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞—Ü–∏–∏
                    animationStartTime = Date.now();
                    animationDuration = 400;
                    
                    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
                    showTeleportMessage(teleportTypeChar, currentPos, targetPos);
                    
                    // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ —à–∞–≥–æ–≤ –∑–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞
                    steps++;
                    updateUI();
                    
                    return;
                }
            }
            
            // –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –ø–æ–¥—Ö–æ–¥—è—â–∏–π —Ç–µ–ª–µ–ø–æ—Ä—Ç, –æ—Å—Ç–∞–µ–º—Å—è –Ω–∞ –º–µ—Å—Ç–µ
            gameState = GAME_STATES.IDLE;
        }

        // –ù–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫—É–ª–¥–∞—É–Ω–∞ —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞—Ü–∏–∏
        function handleTeleportCooldown() {
            const now = Date.now();
            const remaining = teleportCooldown - (now - lastTeleportTime);
            
            if (remaining > 0) {
                gameState = GAME_STATES.TELEPORT_COOLDOWN;
                if (stateDisplay) stateDisplay.textContent = "–ü–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∞ —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞...";
            } else {
                gameState = GAME_STATES.IDLE;
                lastTeleportPosition = null;
            }
        }

        function activateTrap() {
            gameState = GAME_STATES.TRAPPED;
            if (stateDisplay) stateDisplay.textContent = "–í –ª–æ–≤—É—à–∫–µ!";
            
            showTrapMessage();
            
            setTimeout(() => {
                if (gameState === GAME_STATES.TRAPPED) {
                    gameState = GAME_STATES.IDLE;
                    updateUI();
                }
            }, 2000);
        }

        function showTrapMessage() {
            const trapMsg = document.createElement('div');
            trapMsg.className = 'message';
            trapMsg.innerHTML = `
                <div class="message-title" style="color: #FF4500">–õ–æ–≤—É—à–∫–∞!</div>
                <div style="margin: 20px 0; font-size: 1.2rem">
                    –ö–æ—Ç–∏–∫ –∑–∞—Å—Ç—Ä—è–ª –Ω–∞ 2 —Å–µ–∫—É–Ω–¥—ã!
                </div>
            `;
            
            document.querySelector('.game-wrapper').appendChild(trapMsg);
            
            setTimeout(() => {
                trapMsg.classList.add('show');
            }, 10);
            
            setTimeout(() => {
                trapMsg.classList.remove('show');
                setTimeout(() => {
                    trapMsg.remove();
                }, 500);
            }, 1500);
        }

        function showTeleportMessage(teleportType, fromPos, toPos) {
            const teleportMsg = document.createElement('div');
            teleportMsg.className = 'message';
            teleportMsg.innerHTML = `
                <div class="message-title" style="color: ${getTeleportColor(teleportType)}">–¢–µ–ª–µ–ø–æ—Ä—Ç ${teleportType}!</div>
                <div style="margin: 20px 0; font-size: 1.2rem">
                    –ö–æ—Ç–∏–∫ –ø–µ—Ä–µ–º–µ—â—ë–Ω –æ—Ç (${fromPos.x}, ${fromPos.y}) –∫ (${toPos.x}, ${toPos.y})
                </div>
                <div style="margin: 10px 0; font-size: 1rem; color: #aaa">
                    –¢–µ–ª–µ–ø–æ—Ä—Ç —Ä–∞–±–æ—Ç–∞–µ—Ç –≤ –æ–±–µ —Å—Ç–æ—Ä–æ–Ω—ã! –ó–∞–¥–µ—Ä–∂–∫–∞ 1 —Å–µ–∫.
                </div>
            `;
            
            document.querySelector('.game-wrapper').appendChild(teleportMsg);
            
            setTimeout(() => {
                teleportMsg.classList.add('show');
            }, 10);
            
            setTimeout(() => {
                teleportMsg.classList.remove('show');
                setTimeout(() => {
                    teleportMsg.remove();
                }, 500);
            }, 1500);
        }

        function showCooldownMessage() {
            const cooldownMsg = document.createElement('div');
            cooldownMsg.className = 'cooldown-message';
            cooldownMsg.textContent = "–¢–µ–ª–µ–ø–æ—Ä—Ç –ø–µ—Ä–µ–∑–∞—Ä—è–∂–∞–µ—Ç—Å—è! –ü–æ–¥–æ–∂–¥–∏—Ç–µ 1 —Å–µ–∫—É–Ω–¥—É.";
            cooldownMsg.style.position = 'absolute';
            cooldownMsg.style.top = '50%';
            cooldownMsg.style.left = '50%';
            cooldownMsg.style.transform = 'translate(-50%, -50%)';
            cooldownMsg.style.zIndex = '100';
            
            document.querySelector('.game-wrapper').appendChild(cooldownMsg);
            
            setTimeout(() => {
                cooldownMsg.remove();
            }, 1000);
        }

        function getTeleportColor(type) {
            switch(type) {
                case 'A': return COLORS.TELEPORT_A;
                case 'B': return COLORS.TELEPORT_B;
                case 'C': return COLORS.TELEPORT_C;
                default: return COLORS.TELEPORT_A;
            }
        }

        function toggleHint() {
            hintVisible = !hintVisible;
            updateUI();
        }

        function updateUI() {
            if (stepsDisplay) stepsDisplay.textContent = steps;
            
            if (stateDisplay) {
                switch(gameState) {
                    case GAME_STATES.IDLE:
                        stateDisplay.textContent = "–ì–æ—Ç–æ–≤";
                        break;
                    case GAME_STATES.MOVING:
                        stateDisplay.textContent = "–î–≤–∏–∂–µ—Ç—Å—è";
                        break;
                    case GAME_STATES.WIN:
                        stateDisplay.textContent = "–ü–æ–±–µ–¥–∞!";
                        break;
                    case GAME_STATES.TRAPPED:
                        stateDisplay.textContent = "–í –ª–æ–≤—É—à–∫–µ!";
                        break;
                    case GAME_STATES.TELEPORTING:
                        stateDisplay.textContent = "–¢–µ–ª–µ–ø–æ—Ä—Ç–∞—Ü–∏—è!";
                        break;
                    case GAME_STATES.TELEPORT_COOLDOWN:
                        stateDisplay.textContent = "–ü–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∞...";
                        break;
                }
            }
            
            if (hintBtn) {
                hintBtn.textContent = hintVisible ? "–°–∫—Ä—ã—Ç—å –ø–æ–¥—Å–∫–∞–∑–∫—É" : "–ü–æ–∫–∞–∑–∞—Ç—å –ø–æ–¥—Å–∫–∞–∑–∫—É";
            }
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—É–ª–¥–∞—É–Ω —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞—Ü–∏–∏
            if (gameState === GAME_STATES.TELEPORT_COOLDOWN) {
                const now = Date.now();
                if (now - lastTeleportTime >= teleportCooldown) {
                    gameState = GAME_STATES.IDLE;
                    updateUI();
                }
            }
        }

        function resizeCanvas() {
            if (!canvas) return;
            
            const container = document.querySelector('.game-wrapper');
            if (!container) return;
            
            const maxWidth = container.clientWidth;
            
            const calculatedCellSize = Math.max(20, Math.floor(Math.min(maxWidth / MAZE_SIZE, 40)));
            
            if (calculatedCellSize !== cellSize) {
                cellSize = calculatedCellSize;
                
                catPixelPos.x = catGridPos.x * cellSize;
                catPixelPos.y = catGridPos.y * cellSize;
                
                drawTeleportConnections();
            }
            
            canvas.width = MAZE_SIZE * cellSize;
            canvas.height = MAZE_SIZE * cellSize;
        }

        // =============================================
        // –û–¢–†–ò–°–û–í–ö–ê –ò–ì–†–´
        // =============================================
        
        function gameLoop() {
            if (!ctx || !canvas) {
                requestAnimationFrame(gameLoop);
                return;
            }
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawMaze();
            
            if (gameState === GAME_STATES.MOVING || gameState === GAME_STATES.TELEPORTING) {
                updateCatPosition();
            }
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—É–ª–¥–∞—É–Ω —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞—Ü–∏–∏
            if (gameState === GAME_STATES.TELEPORT_COOLDOWN) {
                handleTeleportCooldown();
            }
            
            drawCat(catPixelPos.x, catPixelPos.y, cellSize);
            
            if (hintVisible) {
                drawHint();
            }
            
            requestAnimationFrame(gameLoop);
        }

        function drawMaze() {
            if (!ctx || !currentMaze || currentMaze.length === 0) return;
            
            for (let y = 0; y < MAZE_SIZE; y++) {
                for (let x = 0; x < MAZE_SIZE; x++) {
                    const cellX = x * cellSize;
                    const cellY = y * cellSize;
                    
                    let color;
                    switch(currentMaze[y][x]) {
                        case CELL_TYPES.PATH:
                            color = COLORS.PATH;
                            break;
                        case CELL_TYPES.WALL:
                            color = COLORS.MAZE_WALL;
                            break;
                        case CELL_TYPES.START:
                            color = COLORS.START;
                            break;
                        case CELL_TYPES.EXIT:
                            color = COLORS.EXIT;
                            break;
                        case CELL_TYPES.TRAP:
                            color = COLORS.TRAP;
                            break;
                        case CELL_TYPES.TELEPORT_A:
                            color = COLORS.TELEPORT_A;
                            break;
                        case CELL_TYPES.TELEPORT_B:
                            color = COLORS.TELEPORT_B;
                            break;
                        case CELL_TYPES.TELEPORT_C:
                            color = COLORS.TELEPORT_C;
                            break;
                        case CELL_TYPES.ONE_WAY_UP:
                        case CELL_TYPES.ONE_WAY_RIGHT:
                        case CELL_TYPES.ONE_WAY_DOWN:
                        case CELL_TYPES.ONE_WAY_LEFT:
                            color = COLORS.ONE_WAY;
                            break;
                        default:
                            color = COLORS.PATH;
                    }
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(cellX, cellY, cellSize, cellSize);
                    
                    switch(currentMaze[y][x]) {
                        case CELL_TYPES.TRAP:
                            drawTrap(cellX, cellY, cellSize);
                            break;
                        case CELL_TYPES.TELEPORT_A:
                        case CELL_TYPES.TELEPORT_B:
                        case CELL_TYPES.TELEPORT_C:
                            drawTeleport(cellX, cellY, cellSize, currentMaze[y][x]);
                            break;
                        case CELL_TYPES.ONE_WAY_UP:
                            drawOneWay(cellX, cellY, cellSize, 'up');
                            break;
                        case CELL_TYPES.ONE_WAY_RIGHT:
                            drawOneWay(cellX, cellY, cellSize, 'right');
                            break;
                        case CELL_TYPES.ONE_WAY_DOWN:
                            drawOneWay(cellX, cellY, cellSize, 'down');
                            break;
                        case CELL_TYPES.ONE_WAY_LEFT:
                            drawOneWay(cellX, cellY, cellSize, 'left');
                            break;
                    }
                    
                    if (currentMaze[y][x] === CELL_TYPES.WALL) {
                        ctx.strokeStyle = '#333';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(cellX, cellY, cellSize, cellSize);
                    }
                    
                    if (currentMaze[y][x] === CELL_TYPES.EXIT) {
                        drawExit(cellX, cellY, cellSize);
                    }
                    
                    if (currentMaze[y][x] >= CELL_TYPES.TELEPORT_A && currentMaze[y][x] <= CELL_TYPES.TELEPORT_C) {
                        const teleportType = String.fromCharCode(65 + (currentMaze[y][x] - CELL_TYPES.TELEPORT_A));
                        ctx.fillStyle = '#FFFFFF';
                        ctx.font = `bold ${cellSize * 0.5}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(teleportType, cellX + cellSize/2, cellY + cellSize/2);
                    }
                }
            }
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            
            for (let x = 0; x <= MAZE_SIZE; x++) {
                ctx.beginPath();
                ctx.moveTo(x * cellSize, 0);
                ctx.lineTo(x * cellSize, canvas.height);
                ctx.stroke();
            }
            
            for (let y = 0; y <= MAZE_SIZE; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * cellSize);
                ctx.lineTo(canvas.width, y * cellSize);
                ctx.stroke();
            }
        }

        function drawTrap(x, y, size) {
            if (!ctx) return;
            
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.moveTo(x + size/2, y + size*0.2);
            ctx.lineTo(x + size*0.8, y + size*0.8);
            ctx.lineTo(x + size*0.2, y + size*0.8);
            ctx.closePath();
            ctx.fill();
            
            ctx.fillStyle = '#FF4500';
            ctx.fillRect(x + size*0.47, y + size*0.3, size*0.06, size*0.3);
            ctx.beginPath();
            ctx.arc(x + size/2, y + size*0.65, size*0.05, 0, Math.PI*2);
            ctx.fill();
        }

        function drawTeleport(x, y, size, teleportType) {
            if (!ctx) return;
            
            let color;
            switch(teleportType) {
                case CELL_TYPES.TELEPORT_A: color = COLORS.TELEPORT_A; break;
                case CELL_TYPES.TELEPORT_B: color = COLORS.TELEPORT_B; break;
                case CELL_TYPES.TELEPORT_C: color = COLORS.TELEPORT_C; break;
                default: color = COLORS.TELEPORT_A;
            }
            
            const time = Date.now() / 1000;
            const pulse = Math.sin(time * 3) * 0.1 + 0.9;
            
            ctx.strokeStyle = color;
            ctx.lineWidth = size * 0.08 * pulse;
            ctx.beginPath();
            ctx.arc(x + size/2, y + size/2, size*0.4, 0, Math.PI*2);
            ctx.stroke();
            
            ctx.fillStyle = color;
            ctx.globalAlpha = 0.3;
            ctx.beginPath();
            ctx.arc(x + size/2, y + size/2, size*0.3, 0, Math.PI*2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }

        function drawOneWay(x, y, size, direction) {
            if (!ctx) return;
            
            ctx.fillStyle = '#FFFFFF';
            
            switch(direction) {
                case 'up':
                    ctx.beginPath();
                    ctx.moveTo(x + size/2, y + size*0.2);
                    ctx.lineTo(x + size*0.3, y + size*0.5);
                    ctx.lineTo(x + size*0.7, y + size*0.5);
                    ctx.closePath();
                    ctx.fill();
                    break;
                    
                case 'right':
                    ctx.beginPath();
                    ctx.moveTo(x + size*0.8, y + size/2);
                    ctx.lineTo(x + size*0.5, y + size*0.3);
                    ctx.lineTo(x + size*0.5, y + size*0.7);
                    ctx.closePath();
                    ctx.fill();
                    break;
                    
                case 'down':
                    ctx.beginPath();
                    ctx.moveTo(x + size/2, y + size*0.8);
                    ctx.lineTo(x + size*0.3, y + size*0.5);
                    ctx.lineTo(x + size*0.7, y + size*0.5);
                    ctx.closePath();
                    ctx.fill();
                    break;
                    
                case 'left':
                    ctx.beginPath();
                    ctx.moveTo(x + size*0.2, y + size/2);
                    ctx.lineTo(x + size*0.5, y + size*0.3);
                    ctx.lineTo(x + size*0.5, y + size*0.7);
                    ctx.closePath();
                    ctx.fill();
                    break;
            }
        }

        function drawExit(x, y, size) {
            if (!ctx) return;
            
            ctx.fillStyle = '#228B22';
            const doorWidth = size * 0.6;
            const doorHeight = size * 0.8;
            const doorX = x + (size - doorWidth) / 2;
            const doorY = y + (size - doorHeight) / 2;
            ctx.fillRect(doorX, doorY, doorWidth, doorHeight);
            
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(doorX + doorWidth * 0.8, doorY + doorHeight / 2, size * 0.08, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#FFFFFF';
            ctx.font = `bold ${size * 0.3}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('–í—ã—Ö–æ–¥', x + size / 2, y + size / 2);
        }

        function drawHint() {
            if (!ctx) return;
            
            let currentX = catGridPos.x;
            let currentY = catGridPos.y;
            
            const mazeCopy = JSON.parse(JSON.stringify(currentMaze));
            const path = findPathDFS(mazeCopy, currentX, currentY, exitPos.x, exitPos.y);
            
            if (path && path.length > 0) {
                for (let i = 0; i < path.length; i++) {
                    const point = path[i];
                    const cellX = point.x * cellSize;
                    const cellY = point.y * cellSize;
                    
                    if ((point.x === catGridPos.x && point.y === catGridPos.y) || 
                        (point.x === exitPos.x && point.y === exitPos.y)) {
                        continue;
                    }
                    
                    ctx.fillStyle = COLORS.HINT;
                    ctx.beginPath();
                    ctx.arc(cellX + cellSize/2, cellY + cellSize/2, cellSize * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function findPathDFS(maze, startX, startY, endX, endY) {
            const stack = [{x: startX, y: startY, path: []}];
            const visited = new Set();
            
            while (stack.length > 0) {
                const {x, y, path} = stack.pop();
                const key = `${x},${y}`;
                
                if (visited.has(key)) continue;
                visited.add(key);
                
                const newPath = [...path, {x, y}];
                
                if (x === endX && y === endY) {
                    return newPath;
                }
                
                const directions = [
                    {dx: 0, dy: -1},
                    {dx: 1, dy: 0},
                    {dx: 0, dy: 1},
                    {dx: -1, dy: 0}
                ];
                
                for (const dir of directions) {
                    const newX = x + dir.dx;
                    const newY = y + dir.dy;
                    
                    if (newX >= 0 && newX < MAZE_SIZE && 
                        newY >= 0 && newY < MAZE_SIZE &&
                        maze[newY][newX] !== 1 && 
                        !visited.has(`${newX},${newY}`)) {
                        stack.push({x: newX, y: newY, path: newPath});
                    }
                }
            }
            
            return null;
        }

        function drawCat(x, y, size) {
            if (!ctx) return;
            ctx.save();
            
            const centerX = x + size / 2;
            const centerY = y + size / 2;
            
            drawBody(centerX, centerY, size);
            drawHead(centerX, centerY, size);
            drawEars(centerX, centerY, size);
            drawEyes(centerX, centerY, size);
            drawNose(centerX, centerY, size);
            drawWhiskers(centerX, centerY, size);
            drawPaws(centerX, centerY, size);
            drawTail(centerX, centerY, size);
            
            ctx.restore();
        }

        function drawBody(centerX, centerY, size) {
            const bodyWidth = size * 0.9;
            const bodyHeight = size * 0.7;
            
            ctx.fillStyle = COLORS.CAT_MAIN;
            ctx.beginPath();
            ctx.ellipse(centerX, centerY + size * 0.1, bodyWidth/2, bodyHeight/2, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = COLORS.CAT_ACCENT;
            ctx.beginPath();
            ctx.ellipse(centerX - size * 0.1, centerY + size * 0.05, bodyWidth/2.2, bodyHeight/2.2, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawHead(centerX, centerY, size) {
            const headRadius = size * 0.4;
            
            ctx.fillStyle = COLORS.CAT_MAIN;
            ctx.beginPath();
            ctx.arc(centerX, centerY - size * 0.15, headRadius, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawEars(centerX, centerY, size) {
            const earSize = size * 0.25;
            
            ctx.fillStyle = COLORS.CAT_MAIN;
            ctx.beginPath();
            ctx.moveTo(centerX - size * 0.25, centerY - size * 0.55);
            ctx.lineTo(centerX - size * 0.45, centerY - size * 0.75);
            ctx.lineTo(centerX - size * 0.15, centerY - size * 0.55);
            ctx.closePath();
            ctx.fill();
            
            ctx.fillStyle = COLORS.CAT_EAR_INNER;
            ctx.beginPath();
            ctx.moveTo(centerX - size * 0.25, centerY - size * 0.55);
            ctx.lineTo(centerX - size * 0.4, centerY - size * 0.7);
            ctx.lineTo(centerX - size * 0.18, centerY - size * 0.55);
            ctx.closePath();
            ctx.fill();
            
            ctx.fillStyle = COLORS.CAT_MAIN;
            ctx.beginPath();
            ctx.moveTo(centerX + size * 0.25, centerY - size * 0.55);
            ctx.lineTo(centerX + size * 0.45, centerY - size * 0.75);
            ctx.lineTo(centerX + size * 0.15, centerY - size * 0.55);
            ctx.closePath();
            ctx.fill();
            
            ctx.fillStyle = COLORS.CAT_EAR_INNER;
            ctx.beginPath();
            ctx.moveTo(centerX + size * 0.25, centerY - size * 0.55);
            ctx.lineTo(centerX + size * 0.4, centerY - size * 0.7);
            ctx.lineTo(centerX + size * 0.18, centerY - size * 0.55);
            ctx.closePath();
            ctx.fill();
        }

        function drawEyes(centerX, centerY, size) {
            const eyeRadius = size * 0.12;
            const pupilRadius = size * 0.05;
            
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(centerX - size * 0.15, centerY - size * 0.2, eyeRadius, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(centerX - size * 0.15, centerY - size * 0.2, pupilRadius, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(centerX - size * 0.18, centerY - size * 0.22, pupilRadius * 0.5, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(centerX + size * 0.15, centerY - size * 0.2, eyeRadius, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(centerX + size * 0.15, centerY - size * 0.2, pupilRadius, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(centerX + size * 0.12, centerY - size * 0.22, pupilRadius * 0.5, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawNose(centerX, centerY, size) {
            ctx.fillStyle = '#FFB6C1';
            ctx.beginPath();
            ctx.moveTo(centerX, centerY - size * 0.1);
            ctx.lineTo(centerX - size * 0.05, centerY - size * 0.05);
            ctx.lineTo(centerX + size * 0.05, centerY - size * 0.05);
            ctx.closePath();
            ctx.fill();
        }

        function drawWhiskers(centerX, centerY, size) {
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1;
            
            for (let i = 0; i < 3; i++) {
                const yOffset = i * size * 0.05 - size * 0.05;
                ctx.beginPath();
                ctx.moveTo(centerX - size * 0.05, centerY - size * 0.05 + yOffset);
                ctx.lineTo(centerX - size * 0.25, centerY - size * 0.05 + yOffset);
                ctx.stroke();
            }
            
            for (let i = 0; i < 3; i++) {
                const yOffset = i * size * 0.05 - size * 0.05;
                ctx.beginPath();
                ctx.moveTo(centerX + size * 0.05, centerY - size * 0.05 + yOffset);
                ctx.lineTo(centerX + size * 0.25, centerY - size * 0.05 + yOffset);
                ctx.stroke();
            }
        }

        function drawPaws(centerX, centerY, size) {
            ctx.fillStyle = COLORS.CAT_MAIN;
            
            ctx.beginPath();
            ctx.ellipse(centerX - size * 0.3, centerY + size * 0.35, size * 0.1, size * 0.08, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.ellipse(centerX + size * 0.3, centerY + size * 0.35, size * 0.1, size * 0.08, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.ellipse(centerX - size * 0.25, centerY + size * 0.4, size * 0.12, size * 0.1, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.ellipse(centerX + size * 0.25, centerY + size * 0.4, size * 0.12, size * 0.1, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawTail(centerX, centerY, size) {
            ctx.strokeStyle = COLORS.CAT_MAIN;
            ctx.lineWidth = size * 0.08;
            ctx.lineCap = 'round';
            
            ctx.beginPath();
            ctx.moveTo(centerX + size * 0.4, centerY + size * 0.2);
            ctx.bezierCurveTo(
                centerX + size * 0.6, centerY + size * 0.1,
                centerX + size * 0.7, centerY + size * 0.3,
                centerX + size * 0.5, centerY + size * 0.4
            );
            ctx.stroke();
        }

        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
